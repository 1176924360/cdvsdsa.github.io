<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring_aop</title>
      <link href="/2019/05/29/spring-aop/"/>
      <url>/2019/05/29/spring-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringAop的学习"><a href="#SpringAop的学习" class="headerlink" title="SpringAop的学习"></a>SpringAop的学习</h2><h3 id="什么是aop"><a href="#什么是aop" class="headerlink" title="什么是aop"></a>什么是aop</h3><p>aop即是面向切面的编程，在程序运行期间动态地将某段程序代码切入到指定位置进行运行的编程方式。其原理是基于动态代理。</p><a id="more"></a><h3 id="aop编程步骤"><a href="#aop编程步骤" class="headerlink" title="aop编程步骤"></a>aop编程步骤</h3><h4 id="1-在maven工程中导入aspects依赖"><a href="#1-在maven工程中导入aspects依赖" class="headerlink" title="1.在maven工程中导入aspects依赖"></a>1.在maven工程中导入aspects依赖</h4><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-定义一个业务逻辑类"><a href="#2-定义一个业务逻辑类" class="headerlink" title="2.定义一个业务逻辑类"></a>2.定义一个业务逻辑类</h4><p>在此定义一个除法的业务逻辑<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathCaculator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"方法开始"</span>);<br>        <span class="hljs-keyword">return</span> i/j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="3-定义切面类"><a href="#3-定义切面类" class="headerlink" title="3.定义切面类"></a>3.定义切面类</h4><p>此切面类在调用业务逻辑之前，之后，返回正常，出现异常等情况下被执行<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logStart</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        Object[] args = joinPoint.getArgs();<br>        System.out.println(joinPoint.getSignature().getName()+<span class="hljs-string">"开始之前"</span>+ Arrays.asList(args));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logEnd</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">"结束后"</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logReturn</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span></span>&#123;<br>        System.out.println(joinPoint.getSignature().getName()+<span class="hljs-string">"正常返回:"</span> + result);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logException</span><span class="hljs-params">(JoinPoint joinPoint, Exception exception)</span></span>&#123;<br>        System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">"出现异常:"</span> + exception);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通知的方法有前置、后置、返回正常值、异常、环绕通知。<br>前置：@Before，后置：@After， 返回正常：@AfterReturning， 异常：@AfterThrowing， 环绕：@Around</p><h4 id="4-给切面类目标方法标注何时何地运行"><a href="#4-给切面类目标方法标注何时何地运行" class="headerlink" title="4.给切面类目标方法标注何时何地运行"></a>4.给切面类目标方法标注何时何地运行</h4><p>@Before(“public int cn.hdu.aop.MathCaculator.<em>(..)”)<br>@After(“public int cn.hdu.aop.MathCaculator.</em>(..)”)<br>…..<br>如果目标方法为同一个时，可以提取公共切入点<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public int cn.hdu.aop.MathCaculator.*(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">point</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>如果本类使用此切点时，直接使用方法名，如：@Before(“point()”)<br>如果别的类使用此切点时，使用切点的类名，如：@Before(“cn.hdu.aop.LogAspect.point()”)</p><h4 id="5-将切面类与业务逻辑类加入到容器中"><a href="#5-将切面类与业务逻辑类加入到容器中" class="headerlink" title="5.将切面类与业务逻辑类加入到容器中"></a>5.将切面类与业务逻辑类加入到容器中</h4><p>在配置类中将上述的类加入到容器<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfigOfAOP</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MathCaculator <span class="hljs-title">mathCaculator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MathCaculator();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LogAspect <span class="hljs-title">logAspect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogAspect();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="6-需告知spring哪个类是切面类"><a href="#6-需告知spring哪个类是切面类" class="headerlink" title="6.需告知spring哪个类是切面类"></a>6.需告知spring哪个类是切面类</h4><p>在切面类上使用@Aspect注解</p><h4 id="7-在配置类中加入开启切面自动代理注解"><a href="#7-在配置类中加入开启切面自动代理注解" class="headerlink" title="7.在配置类中加入开启切面自动代理注解"></a>7.在配置类中加入开启切面自动代理注解</h4><p>@EnableAspectJAutoProxy</p><h4 id="8-测试代码"><a href="#8-测试代码" class="headerlink" title="8.测试代码"></a>8.测试代码</h4><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AOPTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfAOP.class);<br>        MathCaculator contextBean = (MathCaculator) context.getBean(<span class="hljs-string">"mathCaculator"</span>);<br>        contextBean.div(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在bean容器中获取mathCaculator组件，调用组件的div()方法</p><p><img src="/2019/05/29/spring-aop/QQ截图20190529123653.png" alt="测试结果"></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AOPTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfAOP.class);<br>        MathCaculator contextBean = (MathCaculator) context.getBean(<span class="hljs-string">"mathCaculator"</span>);<br>        contextBean.div(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，出现异常，其测试结果为：</p><p><img src="/2019/05/29/spring-aop/QQ截图20190529123945.png" alt="测试结果"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring_属性赋值与自动装配</title>
      <link href="/2019/05/28/spring-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2019/05/28/spring-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="spring-属性赋值与自动装配"><a href="#spring-属性赋值与自动装配" class="headerlink" title="spring_属性赋值与自动装配"></a>spring_属性赋值与自动装配</h2><h3 id="1-属性赋值"><a href="#1-属性赋值" class="headerlink" title="1.属性赋值"></a>1.属性赋值</h3><p>使用@value注解便可以使容器中的属性进行赋值</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;22-2&#125;"</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"zhangsan"</span>)<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.nickNmae&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String nickNmae;<br>    <span class="hljs-comment">//get()、set()方法</span><br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><p>1.@Value(“zhangsan”)，在value中直接写入属性，基本数值都可以。<br>2.@Value(“#{22-2}”)，SPEL表达式，在表达式中可以进行运算。<br>3.@Value(“${person.nickNmae}”)，获取到外部配置文件中的值</p><ul><li><p>通过外部配置文件获取属性值时，首先需要编写一个properties文件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties">person.nickNmae=xiaolisi<br></code></pre></td></tr></table></figure></li><li><p>之后再在配置类中使用@PropertySource属性，将外部的配置文件扫描到。</p></li><li>最后，便可以使用${}获取配置文件的值。</li></ul><p>测试代码如下</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyTest</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfproperty.class);<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        showBeanNames(context);<br>        Person person = (Person) context.getBean(<span class="hljs-string">"person"</span>);<br>        System.out.println(person);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBeanNames</span><span class="hljs-params">(ApplicationContext context)</span></span>&#123;<br>        String[] names = context.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528154531.png" alt="测试结果"></p><p>结果可以看到age=20,name=’zhangsan’,nickNmae=’xiaolisi’与注入的属性值相符。</p><h3 id="2-自动装配"><a href="#2-自动装配" class="headerlink" title="2.自动装配"></a>2.自动装配</h3><h4 id="2-1-Autowired注解"><a href="#2-1-Autowired注解" class="headerlink" title="2.1 @Autowired注解"></a>2.1 @Autowired注解</h4><p>在一般的web项目，存在controller层、service层、dao层，在使用service层时需要调用dao层的方法，使用controller层时需要调用service层的方法，并且在当前的类中不创建调用类的实例。这时@Autowired注解就解决了这个问题。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookService</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     BookDao bookDao2;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">"BookService&#123;"</span> +<br>                 <span class="hljs-string">"bookDao="</span> + bookDao2 +<br>                 <span class="hljs-string">'&#125;'</span>;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码为，在BookService类中需要注入BookDao，加上@Autowired注解便可以将BookDao属性加载。将上述代码进行测试</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutowiredTest</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <br>    <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfAutowired.class);<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        BookService bookService = context.getBean(BookService.class);<br>        System.out.println(bookService);<br>        BookDao bookDao = context.getBean(BookDao.class);<br>        System.out.println(bookDao);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528160946.png" alt="测试结果"></p><p>上图可以看出，在BookService中注入的BookDao与bean容器中的BookDao是同一个。<br>@Autowired注解在注入容器中的属性时，首先会按照类型去容器中找到对应的组件。假如@Autowired注解在注入容器中的属性时，首先会按照类型去容器中找到对应的组件。假如@Autowired标注在BookDao bookDao2上，首先它会去找容器中类型为BookDao的组件，如果容器中有多个BookDao的组件，则再根据属性名作为组件id去容器中找，如此时的属性名为bookDao2，则去容器中寻找id名为bookDao2的组件。</p><p>首先，容器中有一个bookDao，将其标记为“1”<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String tag = <span class="hljs-string">"1"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTag</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tag;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTag</span><span class="hljs-params">(String tag)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tag = tag;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"BookDao&#123;"</span> +<br>                <span class="hljs-string">"tag='"</span> + tag + <span class="hljs-string">'\''</span> +<br>                <span class="hljs-string">'&#125;'</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>再在配置类中注入一个BookDao的组件，将其命名为bookDao2，并标记为“2”</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bookDao2"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> BookDao <span class="hljs-title">bookDao</span><span class="hljs-params">()</span></span>&#123;<br>    BookDao bookDao = <span class="hljs-keyword">new</span> BookDao();<br>    bookDao.setTag(<span class="hljs-string">"2"</span>);<br>    <span class="hljs-keyword">return</span> bookDao;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码自动装配的BookDao命名为bookDao2;</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528162335.png" alt="测试结果"></p><p>可以看到，BookService自动装配的BookDao为bookDao2。</p><p>除了按照id，spring也有@Qualifier注解，指定需要装配的组件的id。@Qualifier(“bookDao”)，表明需要装配id为bookDao的组件。</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528162727.png" alt="测试结果"></p><p>可以看到，BookService自动装配的BookDao为bookDao，因为其tag的属性为“1”。</p><p>spring的默认规定自动装配的组件一定要将属性赋值好，没有就报错。将@Qualifier里的属性改为@Qualifier(“bookDao3”)，在没有bookDao3的情况下会报错。</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528163304.png" alt="报错信息"></p><p>从报错可以看到，是因为找不到bookDao3而出错</p><p>这是因为@Autowired中有一个required属性，其属性默认值为true，即自动装配的值必须要赋值好，当将其改为false时，没有赋值也不报错，    @Autowired(required = false)。</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528163600.png" alt="测试结果"></p><p>自动装配还有一个@Primary注解，即在自动装配时使用有@Primary注解的Bean，但是使用@Qualifier后，会使用@Qualifier指定id的bean。</p><h4 id="2-2-Resource注解，-Inject注解"><a href="#2-2-Resource注解，-Inject注解" class="headerlink" title="2.2 @Resource注解，@Inject注解"></a>2.2 @Resource注解，@Inject注解</h4><p>@Resource和@Inject注解是Java规范的注解，与@Autowired一样实现自动装配。</p><ul><li>@Resource注解只有一个name属性，指定获取的组件的id，除此之外不支持其他的功能</li><li>@Inject注解需要在maven中导入相关的依赖，除了没有required的属性，其余都和@Autowired一样使用。</li></ul><h4 id="2-3-Autowired标注位置"><a href="#2-3-Autowired标注位置" class="headerlink" title="2.3 @Autowired标注位置"></a>2.3 @Autowired标注位置</h4><ul><li>属性上就如上所述</li><li>set***()方法上</li><li>标在有参构造器上</li><li>标在参数位置，但是只有一个有参构造器时，@Autowired注解可以省略，也可以进行自动装配</li><li>使用@Bean注解创建对象时，方法的参数从容器中获得<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">color</span><span class="hljs-params">(Car car)</span></span>&#123;<br>        Color color = <span class="hljs-keyword">new</span> Color();<br>        color.setCar(car);<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-4-自定义组件"><a href="#2-4-自定义组件" class="headerlink" title="2.4 自定义组件"></a>2.4 自定义组件</h4><p>spring容器的底层组件都需要实现Aware接口，这是一个总接口，其中还有很多子接口，当实现子接口且重写其方法，便可以自定义组件。<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">BeanNameAware</span>, <span class="hljs-title">EmbeddedValueResolverAware</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">"Ioc:"</span>+applicationContext);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Name:"</span>+name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>&#123;<br>        String value = resolver.resolveStringValue(<span class="hljs-string">"$&#123;os.name&#125;"</span>+ <span class="hljs-string">"....."</span> + <span class="hljs-string">"#&#123;10*2&#125;"</span>);<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述代码中ApplicationContextAware可以实现Ioc容器的创建，BeanNameAware接口可以得到Bean的name，EmbeddedValueResolverAware接口可以解析相应的表达式，如SPLE表达式。</p><h4 id="2-5-Profile环境搭建"><a href="#2-5-Profile环境搭建" class="headerlink" title="2.5 @Profile环境搭建"></a>2.5 @Profile环境搭建</h4><p>spring可以根据当前的环境，动态激活与切换组件，此时需要使用@Profile，此注解的默认值时default环境。</p><p>环境的改变</p><ul><li>可以使用命令行参数，将其改为-Dspring.profiles.active=***，其中等式后面的值为具体的环境。</li><li>也可以在不该变命令行的前提下使用AnnotationConfigApplicationContext的无参构造器，在注册配置类之前，改变其环境，使用.getEnvironment().setActiveProfiles()方法。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring_Bean的生命周期</title>
      <link href="/2019/05/26/spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/05/26/spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="spring中Bean的生命周期的了解"><a href="#spring中Bean的生命周期的了解" class="headerlink" title="spring中Bean的生命周期的了解"></a>spring中Bean的生命周期的了解</h2><p>初识Bean的生命周期：Bean容器的创建—&gt;初始化Bean—-&gt;Bean容器的销毁</p><ul><li>在xml中定义init-method和destroy-method属性，就可以定义初始化与销毁方法</li><li>在注解模式下有三种方法</li></ul><a id="more"></a><p>####1.第一种<br>在@Bean中指定initMethod与destroyMethod属性<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"cn.hdu.bean"</span>)<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfigOfLife</span> </span>&#123;<br><span class="hljs-meta">@Bean</span>(value = <span class="hljs-string">"car"</span>, initMethod = <span class="hljs-string">"init"</span>, destroyMethod = <span class="hljs-string">"destroy"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">car</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在对应的Car类中编写相应的init方法与destroy方法<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><br></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"car..构造器启动"</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"car初始化....."</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"car销毁....."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>测试代码如下<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfLife.class);<br>        System.out.println(<span class="hljs-string">"容器创建"</span>);<br>        context.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>首先new一个容器，打印，关闭容器<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526153517.png" alt="测试代码结果"><br>从结果看，首先创建好的容器会执行构造函数，接着初始化，初始化在Bean的创建与属性赋值之后，再实现测试代码中的输出语句，最后容器关闭后Bean被销毁<br>但是，当创建的Bean为多例模式，则有差异，再配置类的@Bean注解上加入@Scope(“prototype”)注解，其结果为<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526153959.png" alt="多例结果"><br>在多例模式下创建容器时，不执行对bean的构造与初始化，在关闭容器的时候部销毁Bean，多例模式下只有在获取到Bean的时候，会执行构造和初始化，但是不会销毁。<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526154227.png" alt="多例获取Bean的结果"></p><p>####2.第二种<br>通过实现InitializingBean接口完成初始化,实现DisposableBean接口实现销毁<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>,<span class="hljs-title">DisposableBean</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"cat..构造器启动"</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"cat销毁....."</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"cat初始化....."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>####3.第三种<br>由JSR250规范，在方法位置注明@PostConstruct与@PreDestroy注解也可以实现初始化与销毁<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Dog构造函数....."</span>);<br>    &#125;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"Dog初始化......"</span>);<br>    &#125;<br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"Dog销毁......."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>Bean的生命周期在初始化前后还可以执行自定义的逻辑，需要实现BeanPostProcessor接口，BeanPostProcessor接口需要实现两个方法，postProcessBeforeInitialization方法与postProcessAfterInitialization方法。<br>postProcessBeforeInitialization方法在Bean初始化前执行，postProcessAfterInitialization方法在Bean初始化后执行。<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">"初始化之前"</span> + beanName +<span class="hljs-string">"........."</span>+ bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">"初始化之后"</span> + beanName +<span class="hljs-string">"........."</span>+ bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526155632.png" alt="BeanPostProcessor代码结果"></p><p><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526161012.png" alt="通过对代码进行debug，可以发现其initializeBean方法"><br>在initializeBean方法之前有populateBean()方法，查看源码会发现，此方法为Bean赋予属性<br>进入initializeBean方法源码<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526161347.png" alt="invokeInitMethods方法前会调用applyBeanPostProcessorsBeforeInitialization方法"></p><p><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526161520.png" alt="invokeInitMethods方法后会调用applyBeanPostProcessorsAfterInitialization方法"></p><p>Bean的完整生命周期为：容器的创建—&gt;实现构造函数—&gt;初始化前的处理—&gt;Bean初始化—&gt;初始化后的处理—&gt;Bean的销毁</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring组件注册</title>
      <link href="/2019/05/25/spring%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
      <url>/2019/05/25/spring%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="spring一个重要的技术是Ioc与DI"><a href="#spring一个重要的技术是Ioc与DI" class="headerlink" title="spring一个重要的技术是Ioc与DI"></a>spring一个重要的技术是Ioc与DI</h4><p>1.在传统开发中会创建一个xml文件，在其中定义一个bean，如下：<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"people"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.hdu.bean.Person"</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lisi"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"22"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></p><a id="more"></a><p>使用xml使得开发很繁琐。因此，许多人会用注解开发代替传统的xml开发。那么在注解开发时，需要完成上述的bean注入需要怎么做呢?</p><ul><li>需要写配置类，在一个class文件上标注@configration</li><li>在类中写一个方法，方法返回值为注入bean的类型</li><li>方法上可以加@bean(value = “***”)注解,value的属性是此bean的name，类比为xml中的id属性<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"person"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-number">22</span>, <span class="hljs-string">"lisi"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>最后将测试证明，xml与注解得到的bean一样<br>xml测试代码：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span>&#123;<br>        ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"src/main/resource/bean.xml"</span>);<br>        Person person = (Person) context.getBean(<span class="hljs-string">"person"</span>);<br>        System.out.println(person);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="/2019/05/25/spring组件注册/QQ截图20190525213128.png" alt="xml测试结果"><br>注解测试代码：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>            AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);<br>            Object person = context.getBean(<span class="hljs-string">"person"</span>);<br>            System.out.println(person);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>AnnotationConfigApplicationContext类可以得到由@Configuration注解的类。<br><img src="/2019/05/25/spring组件注册/QQ截图20190525214624.png" alt="注解测试结果"></p><p>2.包扫描<br>在传统的xml开发模式中<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.hdu"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure></p><ul><li>使用注解可以在config类上加@ComponentScan(value=”cn.hdu”),value中的内容为需要扫描的包，在这写包上，只要存在class文件上有@Controller、@@Repository、@Service、@Component注解，便可以使用此扫描到。</li><li>在一般的项目中，存在controller层，service层dao层，在这三个包的类中加上@@Repository、@Service、@Controller注解<br><img src="/2019/05/25/spring组件注册/QQ截图20190526124559.png" alt="各个类的分布"><br>配置类的代码<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.hdu"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"person"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-number">17</span>, <span class="hljs-string">"lisi"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>测试类的代码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);<br>        String[] names = context.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>getBeanDefinitionNames()方法可以得到已经创建的bean的名字，并返回一个数组。<br><img src="/2019/05/25/spring组件注册/QQ截图20190526125117.png" alt="包扫面注解测试结果"><br>除却spring自己需要的容器，还扫描到了mainConfig、bookController、bookDao、bookService、person，其中扫面到mainConfig这个配置类是因为@Configuration注解，@Configuration注解的源码为<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<br><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>@Configuration注解上有@Component注解，而@ComponentScan注解是可以扫描到注有@Component注解的类<br>得到person是因为有@Bean注解。</p><ul><li>@ComponentScan注解除了有value属性，还有excludeFilters与includeFilters，当设置了后面的属性，此注解扫描到的包可以由自己定制<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Filter[] excludeFilters() <span class="hljs-keyword">default</span> &#123;&#125;;<br>Filter[] includeFilters() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>这两个属性都需要Filter数组，查看Filter源码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> Filter &#123;<br><br><span class="hljs-comment">/**<br> * The type of filter to use.<br> * &lt;p&gt;Default is &#123;<span class="hljs-doctag">@link</span> FilterType#ANNOTATION&#125;.<br> * <span class="hljs-doctag">@see</span> #classes<br> * <span class="hljs-doctag">@see</span> #pattern<br> */</span><br><span class="hljs-function">FilterType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FilterType.ANNOTATION</span>;<br><span class="hljs-comment">/**<br> * Alias for &#123;<span class="hljs-doctag">@link</span> #classes&#125;.<br> * <span class="hljs-doctag">@see</span> #classes<br> */</span><br><span class="hljs-meta">@AliasFor</span>(<span class="hljs-string">"classes"</span>)<br>Class&lt;?&gt;[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure></p><p>配置Filter，需要FilterType与Class&lt;?&gt;[]，Class&lt;?&gt;[]为需要过滤的类的.class属性，查看FilterType源码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FilterType &#123;<br><br><span class="hljs-comment">/**<br> * Filter candidates marked with a given annotation.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.AnnotationTypeFilter<br> */</span><br>ANNOTATION,<br><span class="hljs-comment">/**<br> * Filter candidates assignable to a given type.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.AssignableTypeFilter<br> */</span><br>ASSIGNABLE_TYPE,<br><span class="hljs-comment">/**<br> * Filter candidates matching a given AspectJ type pattern expression.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.AspectJTypeFilter<br> */</span><br>ASPECTJ,<br><span class="hljs-comment">/**<br> * Filter candidates matching a given regex pattern.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.RegexPatternTypeFilter<br> */</span><br>REGEX,<br><span class="hljs-comment">/** Filter candidates using a given custom<br> * &#123;<span class="hljs-doctag">@link</span> org.springframework.core.type.filter.TypeFilter&#125; implementation.<br> */</span><br>CUSTOM<br>&#125;<br></code></pre></td></tr></table></figure></p><p>可以看出FilterType有5个属性，为ANNOTATION，ASSIGNABLE_TYPE,ASPECTJ,REGEX,CUSTOM</p><ul><li>ANNOTATION为按照注解过滤</li><li>ASSIGNABLE_TYPE为按照类型过滤</li><li>ASPECTJ,REGEX为按表达式过滤</li><li>CUSTOM是自定义<br>举例type为ANNOTATION，其代码为<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.hdu"</span>, excludeFilters = &#123;<br>        <span class="hljs-meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, classes = &#123;<br>                Controller.class, Service.class<br>        &#125;)<br>&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"person"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        System.out.println("start.......");</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-number">17</span>, <span class="hljs-string">"lisi"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2019/05/25/spring组件注册/QQ截图20190526131830.png" alt="使用excludeFilters的测试结果"><br>可以发现Controllery与Service的容器不见了，这是因为excludeFilters属性起作用了</p><ul><li>当type为CUSTOM时，查看CUSTOM可以发现@link org.springframework.core.type.filter.TypeFilter} implementation.注释，即为需要实现TypeFilter的接口，其代码如下<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTypeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeFilter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>            ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>            Resource resource = metadataReader.getResource();<br>            String className = classMetadata.getClassName();<br>            System.out.println(className);<br>            <span class="hljs-keyword">if</span>(className.contains(<span class="hljs-string">"er"</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>其要实现的方法为match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)方法，此方法中有两个参数</p><ul><li><p>metadataReader参数，其方法有</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataReader</span> </span>&#123;<br>    <span class="hljs-function">Resource <span class="hljs-title">getResource</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ClassMetadata <span class="hljs-title">getClassMetadata</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">AnnotationMetadata <span class="hljs-title">getAnnotationMetadata</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>metadataReaderFactory参数为一个metadataReader工厂，可以由工厂得到metadataReader参数</p></li></ul><p>3.作用域与懒加载</p><ul><li>作用域 @Scope注解  其属性有SCOPE_PROTOTYPE，SCOPE_SINGLETON，SCOPE_REQUEST，SCOPE_SESSION四个，最多用的为SCOPE_PROTOTYPE，SCOPE_SINGLETON，一个为多例模式，一个为单例模式，其中默认是单例模式。</li><li>懒加载 @Lazy  在默认单例模式中，只要创建容器，还没有创实例之前，就会完成方法，加入单例模式后，只有创建实例才会完成方法。</li></ul><p>4.按条件判断是否创建bean容器<br>当使用@Conditional()注解后，在创建bean容器之前会先判断@Conditional()中的条件有没有成立，只有成立后才会创建bean容器。<br>Conditional源码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Conditional &#123;<br><span class="hljs-comment">/**<br> * All &#123;<span class="hljs-doctag">@link</span> Condition&#125;s that must &#123;<span class="hljs-doctag">@linkplain</span> Condition#matches match&#125;<br> * in order for the component to be registered.<br> */</span><br>Class&lt;? extends Condition&gt;[] value();<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>使用此注解需要实现Condition接口，实现matches()方法。举例代码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>        Environment environment = context.getEnvironment();<br>        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);<br>        <span class="hljs-keyword">return</span> property.contains(<span class="hljs-string">"Windows"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5  其他创建bean容器的注解</p><ul><li>@Import注解<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Import &#123;<br><span class="hljs-comment">/**<br> * &#123;<span class="hljs-doctag">@link</span> Configuration&#125;, &#123;<span class="hljs-doctag">@link</span> ImportSelector&#125;, &#123;<span class="hljs-doctag">@link</span> ImportBeanDefinitionRegistrar&#125;<br> * or regular component classes to import.<br> */</span><br>Class&lt;?&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在此注解中可以直接写一个需要注入类的.clss的属性，也可以写ImportSelector.class与ImportBeanDefinitionRegistrar.class<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(&#123;Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)<br></code></pre></td></tr></table></figure></p><ul><li>ImportSelector<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br><span class="hljs-comment">/**<br> * Select and return the names of which class(es) should be imported based on<br> * the &#123;<span class="hljs-doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="hljs-doctag">@link</span> Configuration&#125; class.<br> */</span><br>String[] selectImports(AnnotationMetadata importingClassMetadata);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>实现ImportSelector接口，返回String[]</p><ul><li>ImportBeanDefinitionRegistrar<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br><span class="hljs-comment">/**<br> * Register bean definitions as necessary based on the given annotation metadata of<br> * the importing &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class.<br> * &lt;p&gt;Note that &#123;<span class="hljs-doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be<br> * registered here, due to lifecycle constraints related to &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125;<br> * class processing.<br> * <span class="hljs-doctag">@param</span> importingClassMetadata annotation metadata of the importing class<br> * <span class="hljs-doctag">@param</span> registry current bean definition registry<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(<br>AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
