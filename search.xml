<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL_学习day03</title>
      <link href="/2019/06/04/MySQL-%E5%AD%A6%E4%B9%A0day03/"/>
      <url>/2019/06/04/MySQL-%E5%AD%A6%E4%B9%A0day03/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL之索引优化"><a href="#MySQL之索引优化" class="headerlink" title="MySQL之索引优化"></a>MySQL之索引优化</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><p>首先建一张表，并插入数据</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `article`(<br>id INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,<br>author_id INT(10) UNSIGNED NOT NULL,<br>category_id INT(10) UNSIGNED NOT NULL,<br>views INT(10) UNSIGNED NOT NULL,<br>comments INT(10) UNSIGNED NOT NULL,<br>title VARBINARY(255) NOT NULL,<br>content TEXT NOT NULL);<br></code></pre></td></tr></table></figure><a id="more"></a><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO `article`(<br>`author_id`,`category_id`,`views`,`comments`,`title`,`content`)<br>VALUES(1,1,1,1,&apos;1&apos;,&apos;1&apos;),<br>(2,2,2,2,&apos;2&apos;,&apos;2&apos;),<br>(1,1,3,3,&apos;3&apos;,&apos;3&apos;);<br></code></pre></td></tr></table></figure><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604193556.png" alt="单表数据"><br>现要查找到category_id为1，comments为1，且views最大的id</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id,author_id FROM article<br>WHERE category_id = 1<br>AND comments &gt; 1<br>ORDER BY views DESC<br>LIMIT 1;<br></code></pre></td></tr></table></figure><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604194118.png" alt="结果"><br>在不加索引的情况下，器explain的结果为</p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604194249.png" alt="结果"><br>从中可以看到其type的值为ALL，即是全表搜索，ALL表示此SQL语句不好，需要优化。key的值为null，表示没有用到索引，Extra列出现Using filesort，表明有文件内排序，其查询效率底(当数据为百万级别时)。因为查询条件出现了category_id，comments与views，因此给此三个字段添加索引。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_author_ccv ON article(category_id,comments,views);<br></code></pre></td></tr></table></figure><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604195212.png" alt="结果"><br>其type从ALL变成了range，性能得到了提升，并且用到了索引但是，其extra依旧有文件内排序，所以还需要该索引。<br>最终发现只需要将category_id和views两个字段加索引，其结果更好</p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604195527.png" alt="结果"><br>发现，只将category_id和views两个字段加索引后，其type变成ref，性能更好，用到了索引，其ref列为一个常量，且不出现了文件内排序。</p><h4 id="两表"><a href="#两表" class="headerlink" title="两表"></a>两表</h4><p>建表语句</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `class`(<br>`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>`card` INT(10) UNSIGNED NOT NULL,<br>PRIMARY KEY(`id`));<br>CREATE TABLE IF NOT EXISTS `book`(<br>`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>`card` INT(10) UNSIGNED NOT NULL,<br>PRIMARY KEY(`bookid`));<br>INSERT INTO class(card) VALUES<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20)));<br>INSERT INTO book(card) VALUES<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20)));<br></code></pre></td></tr></table></figure><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604200000.png" alt="class表"></p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604200031.png" alt="book表"><br>将两个表进行左连接</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br></code></pre></td></tr></table></figure><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604200157.png" alt="结果"><br>在没有建索引的情况下其explain后得到的表为</p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604200350.png" alt="结果"><br>发现两张表的type都为ALL，且都没有用到索引。<br>给class表的card字段加索引</p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604200552.png" alt="结果"><br>发现class表用到了索引，且其type变为了index。<br>将book表的card字段加索引后，其结果为</p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604200919.png" alt="结果"><br>book表的type为ref，比class加索引的效果更好。</p><p>结论：左连接时给右边的表加索引，右连接时给左边的表加索引</p><h4 id="三表"><a href="#三表" class="headerlink" title="三表"></a>三表</h4><p>建一张phone表</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `phone`(<br>`phoneid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,<br>`card` INT(10) UNSIGNED NOT NULL)ENGINE = INNODB;<br>INSERT INTO phone(card) VALUES<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20))),<br>(FLOOR(1+(RAND() * 20)));<br></code></pre></td></tr></table></figure><p>将class表，book表与phone表进行连接</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM class LEFT JOIN book<br>ON class.card = book.card LEFT JOIN phone<br>ON book.card = phone.card;<br></code></pre></td></tr></table></figure><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604201650.png" alt="查询结果"><br>按照之前两表的结论，做链接需要给右边的表加索引，因此需要给book与phone加索引，加索引后的explain结果为</p><p><img src="/2019/06/04/MySQL-学习day03/QQ截图20190604201911.png" alt="结果"></p><h3 id="索引应该如何使用"><a href="#索引应该如何使用" class="headerlink" title="索引应该如何使用"></a>索引应该如何使用</h3><p>建立staffs表<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE staffs(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>NAME VARCHAR(24) NOT NULL DEFAULT &apos;&apos; COMMENT&apos;姓名&apos;,<br>age INT NOT NULL DEFAULT 0 COMMENT &apos;年龄&apos;,<br>pos VARCHAR(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;职位&apos;,<br>add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;入职时间&apos;<br>)CHARSET utf8 COMMENT &apos;员工记录表&apos;;<br>INSERT INTO staffs(NAME,age,pos,add_time) VALUES<br>(&apos;z3&apos;,22,&apos;manager&apos;,NOW());<br>INSERT INTO staffs(NAME,age,pos,add_time) VALUES<br>(&apos;July&apos;,23,&apos;dev&apos;,NOW());<br>INSERT INTO staffs(NAME,age,pos,add_time) VALUES<br>(&apos;2000&apos;,23,&apos;dev&apos;,NOW());<br></code></pre></td></tr></table></figure></p><p>给name、age、pos字段加索引</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE staffs ADD INDEX adx_staffs_nameAgePos(NAME,age,pos);<br></code></pre></td></tr></table></figure><ul><li>最好是全值匹配</li></ul><p>在查询的时候最好用到NAME,age,pos这三个字段</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM staffs WHERE NAME = &apos;July&apos; AND age =25 AND pos = &apos;dev&apos;;<br></code></pre></td></tr></table></figure><ul><li>最佳左前缀法则</li></ul><p>如果索引了多列，要遵守最左前缀法则。查询从索引的最左前列开始并且不跳过索引的中间列</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM staffs WHERE NAME=&apos;July&apos; AND pos = &apos;dev&apos;;<br></code></pre></td></tr></table></figure><p>如上所示，其where条件为那么与pos，跳过了age，那么pos的索引将不被使用</p><ul><li>索引列上少计算</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM staffs WHERE NAME = &apos;July&apos;;<br>``` <br>上述SQL语句用到了索引<br><br>```mysql<br>EXPLAIN SELECT * FROM staffs WHERE LEFT(NAME,4) = &apos;July&apos;;<br></code></pre></td></tr></table></figure><p>如上的查询索引实现，因为在name列上用到了left函数</p><ul><li>无法使用索引中范围查询右边的索引</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM staffs WHERE NAME = &apos;July&apos; AND age &gt; 25 AND pos = &apos;dev&apos;;<br></code></pre></td></tr></table></figure><p>上述语句age列用到了范围查询，因此pos的索引失效</p><ul><li><p>少用select *，尽量使用覆盖索引</p></li><li><p>使用不等于(!=或&lt;&gt;)会导致索引失效</p></li><li><p>使用is null与is not null，也会使索引失效</p></li><li><p>like以通配符开头(%***)的索引会失效</p></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM staffs WHERE NAME LIKE &apos;%J%&apos;;<br>EXPLAIN SELECT * FROM staffs WHERE NAME LIKE &apos;%J&apos;;<br>EXPLAIN SELECT * FROM staffs WHERE NAME LIKE &apos;J%&apos;;<br></code></pre></td></tr></table></figure><p>如上三条语句，只有最后一条语句索引可以正常使用，当必须要使用”%**%“作为查询条件时，建议使用覆盖索引</p><ul><li><p>字符串不加单引号，索引会失效。因此varchar类型的字段需要加’’</p></li><li><p>少用or，用or连接时会使索引失效’</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_学习day02</title>
      <link href="/2019/06/03/MySQL-%E5%AD%A6%E4%B9%A0day02/"/>
      <url>/2019/06/03/MySQL-%E5%AD%A6%E4%B9%A0day02/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL之explain解读"><a href="#MySQL之explain解读" class="headerlink" title="MySQL之explain解读"></a>MySQL之explain解读</h2><h3 id="explain如何使用"><a href="#explain如何使用" class="headerlink" title="explain如何使用"></a>explain如何使用</h3><p>explain + SQL语句<br>eg：EXPLAIN SELECT * FROM stuinfo;</p><p><img src="/2019/06/03/MySQL-学习day02/QQ截图20190603193328.png" alt="结果"></p><a id="more"></a><h3 id="explain能干什么"><a href="#explain能干什么" class="headerlink" title="explain能干什么"></a>explain能干什么</h3><p>可以对SQL语句进行性能分析</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际石英</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h3 id="结果每列分析"><a href="#结果每列分析" class="headerlink" title="结果每列分析"></a>结果每列分析</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>1.id相同，执行顺序由上至下<br>2.id不同，如果是子查询，id会递增，id值越大优先级越高，越先被执行<br>由此可知：id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>这一列有6个属性</p><ol><li>simple：简单查询</li><li>primary：最外层</li><li>subquery：子查询</li><li>derived：衍生</li><li>union：联合，第二个select出现在union后</li><li>result：从union表获取的select结果</li></ol><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>查找的表名</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type用来评价SQL语句的性能好坏，有8个属性ALL、index、range、ref、eq_ref、const、system、NULL<br>性能从好到坏的排序：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p><ul><li>system：表中只有一行记录</li><li>const：通过索引一次就找到</li><li>eq_ref：唯一性索引扫描，对每个索引键，表中只有一条记录与之匹配</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行</li><li>range：只检索给的范围的行，使用一个索引选择行，一般为where后面出现的between、&lt;、&gt;、in</li><li>indes：全索引扫描</li><li>all：全表扫描</li></ul><h4 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h4><p>possible_keys：显示可能应用到这张表的索引，一个或多个，查询涉及到的字段上若存在索引，则索引被列出，但不一定被查询实际使用<br>key：实际被使用的索引，若果为null，则没有用到索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中<br>key_len：表示所有中使用的字节数，可以通过该列计算查询中使用的索引长度</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示索引的哪一列被使用了，如果可能的话是一个常数</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><ol><li>Using filesort：文件排序</li><li>Using temporary：使用临时表保存中间的结果</li><li>Using index：表示相应的select操作中使用了覆盖索引，避免了访问表的数据行</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring_事务</title>
      <link href="/2019/05/31/spring-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/05/31/spring-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="spring事务的总结"><a href="#spring事务的总结" class="headerlink" title="spring事务的总结"></a>spring事务的总结</h2><h3 id="事务的环境依赖"><a href="#事务的环境依赖" class="headerlink" title="事务的环境依赖"></a>事务的环境依赖</h3><p>在maven中导入spring-aspects、spring-jdbc、mysql-connector-java、c3p0的依赖<br>mysql-connector-java 8.0以上版本的注意：</p><ul><li>DriverClass不在是com.mysql.jdbc.Driver，而是com.mysql.cj.jdbc.Driver</li><li>JdbcUrl除了需要指定具体的库外，还需要加入?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true<br>如果没有符合以上的要求，会报错</li></ul><p><img src="/2019/05/31/spring-事务/QQ截图20190531124243.png" alt="报错信息"></p><p>即会报无法打开JDBC连接的错误</p><a id="more"></a><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;db.username&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;db.password&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;db.driver&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException </span>&#123;<br>        ComboPooledDataSource dataSource = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>        dataSource.setUser(username);<br>        dataSource.setPassword(password);<br>        dataSource.setDriverClass(driver);<br>        dataSource.setJdbcUrl(<span class="hljs-string">"jdbc:mysql://localhost:3306/ee19day01?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException </span>&#123;<br>        JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource());<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties">db.username = root<br>db.password = 123<br>db.driver = com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure><h3 id="注解事务"><a href="#注解事务" class="headerlink" title="注解事务"></a>注解事务</h3><p>在需要事务支持的类上表上事务的注解，@Transactional，之后需要在配置类上注解@EnableTransactionManagement，这个注解是用来打开注解事务的。最后需要注册PlatformTransactionManager组件到容器中。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TxDao txDao;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertService</span><span class="hljs-params">()</span></span>&#123;<br>        txDao.insert();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxDao</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">"INSERT INTO t_user(name, password) VALUES(?, ?)"</span>;<br>        String name = UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        String psw = UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        jdbcTemplate.update(sql, name, psw);<br>        System.out.println(<span class="hljs-string">"插入数据"</span>);<br><span class="hljs-comment">//        int i = 1/0;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"cn.hdu.tx"</span>)<br><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/db.properties"</span>)<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">platformTransactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> PropertyVetoException </span>&#123;<br>        DataSourceTransactionManager transactionManager = <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>        <span class="hljs-keyword">return</span> transactionManager;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>如果spring中没有注册PlatformTransactionManager组件，会报错<br><img src="/2019/05/31/spring-事务/QQ截图20190531130539.png" alt="报错信息"></p><p>报错信息显示没有定义PlatformTransactionManager组件到Bean中</p><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p><img src="/2019/05/31/spring-事务/QQ截图20190531125622.png" alt="数据库原始表"><br>从表中看到最后一条记录的id是15<br>当再执行一遍插入程序后：</p><p><img src="/2019/05/31/spring-事务/QQ截图20190531125817.png" alt="数据库插入数据"><br>可以发现数据库多了一条数据</p><p>当在dao层出现错误时，这里将在dao层加入int i = 1/0程序，执行程序的结果为：</p><p><img src="/2019/05/31/spring-事务/QQ截图20190531130030.png" alt="数据库插入数据时有错误"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这样子便实现了事务的功能，当进行事务时有错误时，事务将进行回滚。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习_diay01</title>
      <link href="/2019/05/29/MySQL%E5%AD%A6%E4%B9%A0-diay011/"/>
      <url>/2019/05/29/MySQL%E5%AD%A6%E4%B9%A0-diay011/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL深入学习-01"><a href="#MySQL深入学习-01" class="headerlink" title="MySQL深入学习_01"></a>MySQL深入学习_01</h2><h3 id="常见的MySQL存储引擎"><a href="#常见的MySQL存储引擎" class="headerlink" title="常见的MySQL存储引擎"></a>常见的MySQL存储引擎</h3><p>MyISAM、InnoDB为常用的两个MySQL数据库存储引擎，其区别为：</p><a id="more"></a><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">主外键</td><td style="text-align:center">N</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">事务</td><td style="text-align:center">N</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">行表锁</td><td style="text-align:center">表锁</td><td style="text-align:center">行锁</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">只缓存索引</td><td style="text-align:center">既缓存索引也缓存真实数据</td></tr><tr><td style="text-align:center">表空间</td><td style="text-align:center">小</td><td style="text-align:center">大</td></tr><tr><td style="text-align:center">关注点</td><td style="text-align:center">性能</td><td style="text-align:center">事务</td></tr></tbody></table><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>假设有一张user表，表中有id、name、email、num</p><ul><li>如果查找表的条件为name<br>建立单值索引：create index idx_user_name on user(name);</li><li>果查找表的条件为name与email<br>建立复合索引：create index idx_user_nameEmail on user(name,email);</li></ul><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引是帮助MySQL高效获得数据的数据结构，索引的目的在于提高查找效率。可以理解为排好序的快速查找的数据结构。在Java开发中，索引一般的数据结构为BTree。</p><h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><p>1.提高数据检索效率，降低数据库的IO成本<br>2.通过索引对数据进行排序，降低数据排序成本，降低CPU的消耗</p><h3 id="需要建立索引的列"><a href="#需要建立索引的列" class="headerlink" title="需要建立索引的列"></a>需要建立索引的列</h3><p>1.主建会建立的为唯一索引<br>2.频繁作为查询条件的字段<br>3.外键关系<br>4.查询中排序的字段<br>5.查询中统计或分组的字段</p><h3 id="不需要建立索引的列"><a href="#不需要建立索引的列" class="headerlink" title="不需要建立索引的列"></a>不需要建立索引的列</h3><p>1.频繁更新的字段<br>2.where条件用不到的字段<br>3.表记录太少(小于300万条数据)<br>4.数据重复且分布平均的字段</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>使用explain + SQL语句，可以对查询语句进行性能分析<br>具体的分析还在学习与整理，需要明天更新</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring_aop</title>
      <link href="/2019/05/29/spring-aop/"/>
      <url>/2019/05/29/spring-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringAop的学习"><a href="#SpringAop的学习" class="headerlink" title="SpringAop的学习"></a>SpringAop的学习</h2><h3 id="什么是aop"><a href="#什么是aop" class="headerlink" title="什么是aop"></a>什么是aop</h3><p>aop即是面向切面的编程，在程序运行期间动态地将某段程序代码切入到指定位置进行运行的编程方式。其原理是基于动态代理。</p><a id="more"></a><h3 id="aop编程步骤"><a href="#aop编程步骤" class="headerlink" title="aop编程步骤"></a>aop编程步骤</h3><h4 id="1-在maven工程中导入aspects依赖"><a href="#1-在maven工程中导入aspects依赖" class="headerlink" title="1.在maven工程中导入aspects依赖"></a>1.在maven工程中导入aspects依赖</h4><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-定义一个业务逻辑类"><a href="#2-定义一个业务逻辑类" class="headerlink" title="2.定义一个业务逻辑类"></a>2.定义一个业务逻辑类</h4><p>在此定义一个除法的业务逻辑<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathCaculator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"方法开始"</span>);<br>        <span class="hljs-keyword">return</span> i/j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="3-定义切面类"><a href="#3-定义切面类" class="headerlink" title="3.定义切面类"></a>3.定义切面类</h4><p>此切面类在调用业务逻辑之前，之后，返回正常，出现异常等情况下被执行<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logStart</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        Object[] args = joinPoint.getArgs();<br>        System.out.println(joinPoint.getSignature().getName()+<span class="hljs-string">"开始之前"</span>+ Arrays.asList(args));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logEnd</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">"结束后"</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logReturn</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span></span>&#123;<br>        System.out.println(joinPoint.getSignature().getName()+<span class="hljs-string">"正常返回:"</span> + result);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logException</span><span class="hljs-params">(JoinPoint joinPoint, Exception exception)</span></span>&#123;<br>        System.out.println(joinPoint.getSignature().getName() + <span class="hljs-string">"出现异常:"</span> + exception);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通知的方法有前置、后置、返回正常值、异常、环绕通知。<br>前置：@Before，后置：@After， 返回正常：@AfterReturning， 异常：@AfterThrowing， 环绕：@Around</p><h4 id="4-给切面类目标方法标注何时何地运行"><a href="#4-给切面类目标方法标注何时何地运行" class="headerlink" title="4.给切面类目标方法标注何时何地运行"></a>4.给切面类目标方法标注何时何地运行</h4><p>@Before(“public int cn.hdu.aop.MathCaculator.<em>(..)”)<br>@After(“public int cn.hdu.aop.MathCaculator.</em>(..)”)<br>…..<br>如果目标方法为同一个时，可以提取公共切入点<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public int cn.hdu.aop.MathCaculator.*(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">point</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>如果本类使用此切点时，直接使用方法名，如：@Before(“point()”)<br>如果别的类使用此切点时，使用切点的类名，如：@Before(“cn.hdu.aop.LogAspect.point()”)</p><h4 id="5-将切面类与业务逻辑类加入到容器中"><a href="#5-将切面类与业务逻辑类加入到容器中" class="headerlink" title="5.将切面类与业务逻辑类加入到容器中"></a>5.将切面类与业务逻辑类加入到容器中</h4><p>在配置类中将上述的类加入到容器<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfigOfAOP</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MathCaculator <span class="hljs-title">mathCaculator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MathCaculator();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LogAspect <span class="hljs-title">logAspect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogAspect();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="6-需告知spring哪个类是切面类"><a href="#6-需告知spring哪个类是切面类" class="headerlink" title="6.需告知spring哪个类是切面类"></a>6.需告知spring哪个类是切面类</h4><p>在切面类上使用@Aspect注解</p><h4 id="7-在配置类中加入开启切面自动代理注解"><a href="#7-在配置类中加入开启切面自动代理注解" class="headerlink" title="7.在配置类中加入开启切面自动代理注解"></a>7.在配置类中加入开启切面自动代理注解</h4><p>@EnableAspectJAutoProxy</p><h4 id="8-测试代码"><a href="#8-测试代码" class="headerlink" title="8.测试代码"></a>8.测试代码</h4><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AOPTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfAOP.class);<br>        MathCaculator contextBean = (MathCaculator) context.getBean(<span class="hljs-string">"mathCaculator"</span>);<br>        contextBean.div(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在bean容器中获取mathCaculator组件，调用组件的div()方法</p><p><img src="/2019/05/29/spring-aop/QQ截图20190529123653.png" alt="测试结果"></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AOPTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfAOP.class);<br>        MathCaculator contextBean = (MathCaculator) context.getBean(<span class="hljs-string">"mathCaculator"</span>);<br>        contextBean.div(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，出现异常，其测试结果为：</p><p><img src="/2019/05/29/spring-aop/QQ截图20190529123945.png" alt="测试结果"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring_属性赋值与自动装配</title>
      <link href="/2019/05/28/spring-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2019/05/28/spring-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="spring-属性赋值与自动装配"><a href="#spring-属性赋值与自动装配" class="headerlink" title="spring_属性赋值与自动装配"></a>spring_属性赋值与自动装配</h2><h3 id="1-属性赋值"><a href="#1-属性赋值" class="headerlink" title="1.属性赋值"></a>1.属性赋值</h3><p>使用@value注解便可以使容器中的属性进行赋值</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;22-2&#125;"</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"zhangsan"</span>)<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.nickNmae&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String nickNmae;<br>    <span class="hljs-comment">//get()、set()方法</span><br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><p>1.@Value(“zhangsan”)，在value中直接写入属性，基本数值都可以。<br>2.@Value(“#{22-2}”)，SPEL表达式，在表达式中可以进行运算。<br>3.@Value(“${person.nickNmae}”)，获取到外部配置文件中的值</p><ul><li><p>通过外部配置文件获取属性值时，首先需要编写一个properties文件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties">person.nickNmae=xiaolisi<br></code></pre></td></tr></table></figure></li><li><p>之后再在配置类中使用@PropertySource属性，将外部的配置文件扫描到。</p></li><li>最后，便可以使用${}获取配置文件的值。</li></ul><p>测试代码如下</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyTest</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfproperty.class);<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        showBeanNames(context);<br>        Person person = (Person) context.getBean(<span class="hljs-string">"person"</span>);<br>        System.out.println(person);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBeanNames</span><span class="hljs-params">(ApplicationContext context)</span></span>&#123;<br>        String[] names = context.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528154531.png" alt="测试结果"></p><p>结果可以看到age=20,name=’zhangsan’,nickNmae=’xiaolisi’与注入的属性值相符。</p><h3 id="2-自动装配"><a href="#2-自动装配" class="headerlink" title="2.自动装配"></a>2.自动装配</h3><h4 id="2-1-Autowired注解"><a href="#2-1-Autowired注解" class="headerlink" title="2.1 @Autowired注解"></a>2.1 @Autowired注解</h4><p>在一般的web项目，存在controller层、service层、dao层，在使用service层时需要调用dao层的方法，使用controller层时需要调用service层的方法，并且在当前的类中不创建调用类的实例。这时@Autowired注解就解决了这个问题。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookService</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     BookDao bookDao2;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">"BookService&#123;"</span> +<br>                 <span class="hljs-string">"bookDao="</span> + bookDao2 +<br>                 <span class="hljs-string">'&#125;'</span>;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码为，在BookService类中需要注入BookDao，加上@Autowired注解便可以将BookDao属性加载。将上述代码进行测试</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutowiredTest</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <br>    <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfAutowired.class);<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        BookService bookService = context.getBean(BookService.class);<br>        System.out.println(bookService);<br>        BookDao bookDao = context.getBean(BookDao.class);<br>        System.out.println(bookDao);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528160946.png" alt="测试结果"></p><p>上图可以看出，在BookService中注入的BookDao与bean容器中的BookDao是同一个。<br>@Autowired注解在注入容器中的属性时，首先会按照类型去容器中找到对应的组件。假如@Autowired注解在注入容器中的属性时，首先会按照类型去容器中找到对应的组件。假如@Autowired标注在BookDao bookDao2上，首先它会去找容器中类型为BookDao的组件，如果容器中有多个BookDao的组件，则再根据属性名作为组件id去容器中找，如此时的属性名为bookDao2，则去容器中寻找id名为bookDao2的组件。</p><p>首先，容器中有一个bookDao，将其标记为“1”<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String tag = <span class="hljs-string">"1"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTag</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tag;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTag</span><span class="hljs-params">(String tag)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tag = tag;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"BookDao&#123;"</span> +<br>                <span class="hljs-string">"tag='"</span> + tag + <span class="hljs-string">'\''</span> +<br>                <span class="hljs-string">'&#125;'</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>再在配置类中注入一个BookDao的组件，将其命名为bookDao2，并标记为“2”</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bookDao2"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> BookDao <span class="hljs-title">bookDao</span><span class="hljs-params">()</span></span>&#123;<br>    BookDao bookDao = <span class="hljs-keyword">new</span> BookDao();<br>    bookDao.setTag(<span class="hljs-string">"2"</span>);<br>    <span class="hljs-keyword">return</span> bookDao;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码自动装配的BookDao命名为bookDao2;</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528162335.png" alt="测试结果"></p><p>可以看到，BookService自动装配的BookDao为bookDao2。</p><p>除了按照id，spring也有@Qualifier注解，指定需要装配的组件的id。@Qualifier(“bookDao”)，表明需要装配id为bookDao的组件。</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528162727.png" alt="测试结果"></p><p>可以看到，BookService自动装配的BookDao为bookDao，因为其tag的属性为“1”。</p><p>spring的默认规定自动装配的组件一定要将属性赋值好，没有就报错。将@Qualifier里的属性改为@Qualifier(“bookDao3”)，在没有bookDao3的情况下会报错。</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528163304.png" alt="报错信息"></p><p>从报错可以看到，是因为找不到bookDao3而出错</p><p>这是因为@Autowired中有一个required属性，其属性默认值为true，即自动装配的值必须要赋值好，当将其改为false时，没有赋值也不报错，    @Autowired(required = false)。</p><p><img src="/2019/05/28/spring-属性赋值与自动装配/QQ截图20190528163600.png" alt="测试结果"></p><p>自动装配还有一个@Primary注解，即在自动装配时使用有@Primary注解的Bean，但是使用@Qualifier后，会使用@Qualifier指定id的bean。</p><h4 id="2-2-Resource注解，-Inject注解"><a href="#2-2-Resource注解，-Inject注解" class="headerlink" title="2.2 @Resource注解，@Inject注解"></a>2.2 @Resource注解，@Inject注解</h4><p>@Resource和@Inject注解是Java规范的注解，与@Autowired一样实现自动装配。</p><ul><li>@Resource注解只有一个name属性，指定获取的组件的id，除此之外不支持其他的功能</li><li>@Inject注解需要在maven中导入相关的依赖，除了没有required的属性，其余都和@Autowired一样使用。</li></ul><h4 id="2-3-Autowired标注位置"><a href="#2-3-Autowired标注位置" class="headerlink" title="2.3 @Autowired标注位置"></a>2.3 @Autowired标注位置</h4><ul><li>属性上就如上所述</li><li>set***()方法上</li><li>标在有参构造器上</li><li>标在参数位置，但是只有一个有参构造器时，@Autowired注解可以省略，也可以进行自动装配</li><li>使用@Bean注解创建对象时，方法的参数从容器中获得<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">color</span><span class="hljs-params">(Car car)</span></span>&#123;<br>        Color color = <span class="hljs-keyword">new</span> Color();<br>        color.setCar(car);<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-4-自定义组件"><a href="#2-4-自定义组件" class="headerlink" title="2.4 自定义组件"></a>2.4 自定义组件</h4><p>spring容器的底层组件都需要实现Aware接口，这是一个总接口，其中还有很多子接口，当实现子接口且重写其方法，便可以自定义组件。<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">BeanNameAware</span>, <span class="hljs-title">EmbeddedValueResolverAware</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">"Ioc:"</span>+applicationContext);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Name:"</span>+name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>&#123;<br>        String value = resolver.resolveStringValue(<span class="hljs-string">"$&#123;os.name&#125;"</span>+ <span class="hljs-string">"....."</span> + <span class="hljs-string">"#&#123;10*2&#125;"</span>);<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述代码中ApplicationContextAware可以实现Ioc容器的创建，BeanNameAware接口可以得到Bean的name，EmbeddedValueResolverAware接口可以解析相应的表达式，如SPLE表达式。</p><h4 id="2-5-Profile环境搭建"><a href="#2-5-Profile环境搭建" class="headerlink" title="2.5 @Profile环境搭建"></a>2.5 @Profile环境搭建</h4><p>spring可以根据当前的环境，动态激活与切换组件，此时需要使用@Profile，此注解的默认值时default环境。</p><p>环境的改变</p><ul><li>可以使用命令行参数，将其改为-Dspring.profiles.active=***，其中等式后面的值为具体的环境。</li><li>也可以在不该变命令行的前提下使用AnnotationConfigApplicationContext的无参构造器，在注册配置类之前，改变其环境，使用.getEnvironment().setActiveProfiles()方法。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring_Bean的生命周期</title>
      <link href="/2019/05/26/spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/05/26/spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="spring中Bean的生命周期的了解"><a href="#spring中Bean的生命周期的了解" class="headerlink" title="spring中Bean的生命周期的了解"></a>spring中Bean的生命周期的了解</h2><p>初识Bean的生命周期：Bean容器的创建—&gt;初始化Bean—-&gt;Bean容器的销毁</p><ul><li>在xml中定义init-method和destroy-method属性，就可以定义初始化与销毁方法</li><li>在注解模式下有三种方法</li></ul><a id="more"></a><p>####1.第一种<br>在@Bean中指定initMethod与destroyMethod属性<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"cn.hdu.bean"</span>)<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfigOfLife</span> </span>&#123;<br><span class="hljs-meta">@Bean</span>(value = <span class="hljs-string">"car"</span>, initMethod = <span class="hljs-string">"init"</span>, destroyMethod = <span class="hljs-string">"destroy"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">car</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在对应的Car类中编写相应的init方法与destroy方法<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><br></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"car..构造器启动"</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"car初始化....."</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"car销毁....."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>测试代码如下<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MyConfigOfLife.class);<br>        System.out.println(<span class="hljs-string">"容器创建"</span>);<br>        context.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>首先new一个容器，打印，关闭容器<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526153517.png" alt="测试代码结果"><br>从结果看，首先创建好的容器会执行构造函数，接着初始化，初始化在Bean的创建与属性赋值之后，再实现测试代码中的输出语句，最后容器关闭后Bean被销毁<br>但是，当创建的Bean为多例模式，则有差异，再配置类的@Bean注解上加入@Scope(“prototype”)注解，其结果为<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526153959.png" alt="多例结果"><br>在多例模式下创建容器时，不执行对bean的构造与初始化，在关闭容器的时候部销毁Bean，多例模式下只有在获取到Bean的时候，会执行构造和初始化，但是不会销毁。<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526154227.png" alt="多例获取Bean的结果"></p><p>####2.第二种<br>通过实现InitializingBean接口完成初始化,实现DisposableBean接口实现销毁<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>,<span class="hljs-title">DisposableBean</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"cat..构造器启动"</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"cat销毁....."</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"cat初始化....."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>####3.第三种<br>由JSR250规范，在方法位置注明@PostConstruct与@PreDestroy注解也可以实现初始化与销毁<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Dog构造函数....."</span>);<br>    &#125;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"Dog初始化......"</span>);<br>    &#125;<br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"Dog销毁......."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>Bean的生命周期在初始化前后还可以执行自定义的逻辑，需要实现BeanPostProcessor接口，BeanPostProcessor接口需要实现两个方法，postProcessBeforeInitialization方法与postProcessAfterInitialization方法。<br>postProcessBeforeInitialization方法在Bean初始化前执行，postProcessAfterInitialization方法在Bean初始化后执行。<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">"初始化之前"</span> + beanName +<span class="hljs-string">"........."</span>+ bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">"初始化之后"</span> + beanName +<span class="hljs-string">"........."</span>+ bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526155632.png" alt="BeanPostProcessor代码结果"></p><p><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526161012.png" alt="通过对代码进行debug，可以发现其initializeBean方法"><br>在initializeBean方法之前有populateBean()方法，查看源码会发现，此方法为Bean赋予属性<br>进入initializeBean方法源码<br><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526161347.png" alt="invokeInitMethods方法前会调用applyBeanPostProcessorsBeforeInitialization方法"></p><p><img src="/2019/05/26/spring-Bean的生命周期/QQ截图20190526161520.png" alt="invokeInitMethods方法后会调用applyBeanPostProcessorsAfterInitialization方法"></p><p>Bean的完整生命周期为：容器的创建—&gt;实现构造函数—&gt;初始化前的处理—&gt;Bean初始化—&gt;初始化后的处理—&gt;Bean的销毁</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring组件注册</title>
      <link href="/2019/05/25/spring%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
      <url>/2019/05/25/spring%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="spring一个重要的技术是Ioc与DI"><a href="#spring一个重要的技术是Ioc与DI" class="headerlink" title="spring一个重要的技术是Ioc与DI"></a>spring一个重要的技术是Ioc与DI</h4><p>1.在传统开发中会创建一个xml文件，在其中定义一个bean，如下：<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"people"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.hdu.bean.Person"</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lisi"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"22"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></p><a id="more"></a><p>使用xml使得开发很繁琐。因此，许多人会用注解开发代替传统的xml开发。那么在注解开发时，需要完成上述的bean注入需要怎么做呢?</p><ul><li>需要写配置类，在一个class文件上标注@configration</li><li>在类中写一个方法，方法返回值为注入bean的类型</li><li>方法上可以加@bean(value = “***”)注解,value的属性是此bean的name，类比为xml中的id属性<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"person"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-number">22</span>, <span class="hljs-string">"lisi"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>最后将测试证明，xml与注解得到的bean一样<br>xml测试代码：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span>&#123;<br>        ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"src/main/resource/bean.xml"</span>);<br>        Person person = (Person) context.getBean(<span class="hljs-string">"person"</span>);<br>        System.out.println(person);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="/2019/05/25/spring组件注册/QQ截图20190525213128.png" alt="xml测试结果"><br>注解测试代码：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>            AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);<br>            Object person = context.getBean(<span class="hljs-string">"person"</span>);<br>            System.out.println(person);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>AnnotationConfigApplicationContext类可以得到由@Configuration注解的类。<br><img src="/2019/05/25/spring组件注册/QQ截图20190525214624.png" alt="注解测试结果"></p><p>2.包扫描<br>在传统的xml开发模式中<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.hdu"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure></p><ul><li>使用注解可以在config类上加@ComponentScan(value=”cn.hdu”),value中的内容为需要扫描的包，在这写包上，只要存在class文件上有@Controller、@@Repository、@Service、@Component注解，便可以使用此扫描到。</li><li>在一般的项目中，存在controller层，service层dao层，在这三个包的类中加上@@Repository、@Service、@Controller注解<br><img src="/2019/05/25/spring组件注册/QQ截图20190526124559.png" alt="各个类的分布"><br>配置类的代码<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.hdu"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"person"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-number">17</span>, <span class="hljs-string">"lisi"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>测试类的代码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);<br>        String[] names = context.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>getBeanDefinitionNames()方法可以得到已经创建的bean的名字，并返回一个数组。<br><img src="/2019/05/25/spring组件注册/QQ截图20190526125117.png" alt="包扫面注解测试结果"><br>除却spring自己需要的容器，还扫描到了mainConfig、bookController、bookDao、bookService、person，其中扫面到mainConfig这个配置类是因为@Configuration注解，@Configuration注解的源码为<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<br><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>@Configuration注解上有@Component注解，而@ComponentScan注解是可以扫描到注有@Component注解的类<br>得到person是因为有@Bean注解。</p><ul><li>@ComponentScan注解除了有value属性，还有excludeFilters与includeFilters，当设置了后面的属性，此注解扫描到的包可以由自己定制<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Filter[] excludeFilters() <span class="hljs-keyword">default</span> &#123;&#125;;<br>Filter[] includeFilters() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>这两个属性都需要Filter数组，查看Filter源码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> Filter &#123;<br><br><span class="hljs-comment">/**<br> * The type of filter to use.<br> * &lt;p&gt;Default is &#123;<span class="hljs-doctag">@link</span> FilterType#ANNOTATION&#125;.<br> * <span class="hljs-doctag">@see</span> #classes<br> * <span class="hljs-doctag">@see</span> #pattern<br> */</span><br><span class="hljs-function">FilterType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FilterType.ANNOTATION</span>;<br><span class="hljs-comment">/**<br> * Alias for &#123;<span class="hljs-doctag">@link</span> #classes&#125;.<br> * <span class="hljs-doctag">@see</span> #classes<br> */</span><br><span class="hljs-meta">@AliasFor</span>(<span class="hljs-string">"classes"</span>)<br>Class&lt;?&gt;[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure></p><p>配置Filter，需要FilterType与Class&lt;?&gt;[]，Class&lt;?&gt;[]为需要过滤的类的.class属性，查看FilterType源码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FilterType &#123;<br><br><span class="hljs-comment">/**<br> * Filter candidates marked with a given annotation.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.AnnotationTypeFilter<br> */</span><br>ANNOTATION,<br><span class="hljs-comment">/**<br> * Filter candidates assignable to a given type.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.AssignableTypeFilter<br> */</span><br>ASSIGNABLE_TYPE,<br><span class="hljs-comment">/**<br> * Filter candidates matching a given AspectJ type pattern expression.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.AspectJTypeFilter<br> */</span><br>ASPECTJ,<br><span class="hljs-comment">/**<br> * Filter candidates matching a given regex pattern.<br> * <span class="hljs-doctag">@see</span> org.springframework.core.type.filter.RegexPatternTypeFilter<br> */</span><br>REGEX,<br><span class="hljs-comment">/** Filter candidates using a given custom<br> * &#123;<span class="hljs-doctag">@link</span> org.springframework.core.type.filter.TypeFilter&#125; implementation.<br> */</span><br>CUSTOM<br>&#125;<br></code></pre></td></tr></table></figure></p><p>可以看出FilterType有5个属性，为ANNOTATION，ASSIGNABLE_TYPE,ASPECTJ,REGEX,CUSTOM</p><ul><li>ANNOTATION为按照注解过滤</li><li>ASSIGNABLE_TYPE为按照类型过滤</li><li>ASPECTJ,REGEX为按表达式过滤</li><li>CUSTOM是自定义<br>举例type为ANNOTATION，其代码为<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.hdu"</span>, excludeFilters = &#123;<br>        <span class="hljs-meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, classes = &#123;<br>                Controller.class, Service.class<br>        &#125;)<br>&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"person"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        System.out.println("start.......");</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-number">17</span>, <span class="hljs-string">"lisi"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2019/05/25/spring组件注册/QQ截图20190526131830.png" alt="使用excludeFilters的测试结果"><br>可以发现Controllery与Service的容器不见了，这是因为excludeFilters属性起作用了</p><ul><li>当type为CUSTOM时，查看CUSTOM可以发现@link org.springframework.core.type.filter.TypeFilter} implementation.注释，即为需要实现TypeFilter的接口，其代码如下<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTypeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeFilter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>            ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>            Resource resource = metadataReader.getResource();<br>            String className = classMetadata.getClassName();<br>            System.out.println(className);<br>            <span class="hljs-keyword">if</span>(className.contains(<span class="hljs-string">"er"</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>其要实现的方法为match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)方法，此方法中有两个参数</p><ul><li><p>metadataReader参数，其方法有</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataReader</span> </span>&#123;<br>    <span class="hljs-function">Resource <span class="hljs-title">getResource</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ClassMetadata <span class="hljs-title">getClassMetadata</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">AnnotationMetadata <span class="hljs-title">getAnnotationMetadata</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>metadataReaderFactory参数为一个metadataReader工厂，可以由工厂得到metadataReader参数</p></li></ul><p>3.作用域与懒加载</p><ul><li>作用域 @Scope注解  其属性有SCOPE_PROTOTYPE，SCOPE_SINGLETON，SCOPE_REQUEST，SCOPE_SESSION四个，最多用的为SCOPE_PROTOTYPE，SCOPE_SINGLETON，一个为多例模式，一个为单例模式，其中默认是单例模式。</li><li>懒加载 @Lazy  在默认单例模式中，只要创建容器，还没有创实例之前，就会完成方法，加入单例模式后，只有创建实例才会完成方法。</li></ul><p>4.按条件判断是否创建bean容器<br>当使用@Conditional()注解后，在创建bean容器之前会先判断@Conditional()中的条件有没有成立，只有成立后才会创建bean容器。<br>Conditional源码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Conditional &#123;<br><span class="hljs-comment">/**<br> * All &#123;<span class="hljs-doctag">@link</span> Condition&#125;s that must &#123;<span class="hljs-doctag">@linkplain</span> Condition#matches match&#125;<br> * in order for the component to be registered.<br> */</span><br>Class&lt;? extends Condition&gt;[] value();<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>使用此注解需要实现Condition接口，实现matches()方法。举例代码<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>        Environment environment = context.getEnvironment();<br>        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);<br>        <span class="hljs-keyword">return</span> property.contains(<span class="hljs-string">"Windows"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>5  其他创建bean容器的注解</p><ul><li>@Import注解<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Import &#123;<br><span class="hljs-comment">/**<br> * &#123;<span class="hljs-doctag">@link</span> Configuration&#125;, &#123;<span class="hljs-doctag">@link</span> ImportSelector&#125;, &#123;<span class="hljs-doctag">@link</span> ImportBeanDefinitionRegistrar&#125;<br> * or regular component classes to import.<br> */</span><br>Class&lt;?&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在此注解中可以直接写一个需要注入类的.clss的属性，也可以写ImportSelector.class与ImportBeanDefinitionRegistrar.class<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(&#123;Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)<br></code></pre></td></tr></table></figure></p><ul><li>ImportSelector<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br><span class="hljs-comment">/**<br> * Select and return the names of which class(es) should be imported based on<br> * the &#123;<span class="hljs-doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="hljs-doctag">@link</span> Configuration&#125; class.<br> */</span><br>String[] selectImports(AnnotationMetadata importingClassMetadata);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>实现ImportSelector接口，返回String[]</p><ul><li>ImportBeanDefinitionRegistrar<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br><span class="hljs-comment">/**<br> * Register bean definitions as necessary based on the given annotation metadata of<br> * the importing &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class.<br> * &lt;p&gt;Note that &#123;<span class="hljs-doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be<br> * registered here, due to lifecycle constraints related to &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125;<br> * class processing.<br> * <span class="hljs-doctag">@param</span> importingClassMetadata annotation metadata of the importing class<br> * <span class="hljs-doctag">@param</span> registry current bean definition registry<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(<br>AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
